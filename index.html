<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Sandbox</title>
        <script src="StreamSaver.js"></script>
<style>
html, body {
  height: 100%;
  margin: 1;
}

.dropzone-style {
  height: 20%;
  background: lightblue;
}
.frame-style {
  height: 80%;
  width: 100%;
}
</style>
    </head>
    <body>
	<div id="app">
		<h1>iframe sandbox. </h1>
		<p>Goal: I wish to be able to load arbitrary and untrusted html/css/js into a iframe. I want protection from spectre et. al. attacks and also from javascript execution escaping from the confines of the iframe</p?>
		<p>Scenario: With a E2E encrypted web application, html/css/js resources are unencrypted and combined locally. I then want to display them inside a sandboxed iframe. </p>
		<p>The POC demonstrates how i envisaged this working:</p>
		<ul>
		  	<li>A writeable stream connects index.html to the service worker - sw.js</li>
  			<li>iframe src is modified to page.html</li>
  			<li>the request is intercepted in sw.js</li>
  			<li>the requested resource name is passed to index.html</li>
  			<li>index.html uses the writeable stream to pass the bytes for the page's content back to sw.js</li>
  			<li>sw.js responds to the original request with the content received</li>
  			<li>The process then repeats for any resource inside page.html</li>
		</ul> 

		<p>Problem: It is not possible to intercept requests inside iframe if allow-same-origin sandbox is NOT set<p>
		<p>Reference: <a href="https://github.com/w3c/ServiceWorker/issues/765">Issue #765</a></p>
		<p>Limitation of POC: Relies on WriteableStream in ServiceWorkers. This has been available in Chrome for some time.  As of Dec 2019 it is available, but not enabled in Firefox nightly (about:config
Javascript.options.writable_streams)</p>
		<p>Note: Firefox nightly helpfully provides the following message: 'An iframe which has both allow-scripts and allow-same-origin for its sandbox attribute can remove its sandboxing.' </p>
  		</p>
  			iframe sandbox attribute:<input id="same-origin-checkbox" type="checkbox" name="origin" value="same" onchange="toggleSameOrigin()" checked>allow-same-origin<br>
  		</p>
	</div>
	    <div id="dropzone" class="dropzone-style">
	    drop files here!
        </div>
        <div><button onclick="reload()">RELOAD IFRAME</button></div>
         <iframe id="embedded" seamless="seamless" sandbox="allow-same-origin allow-scripts" class="frame-style"></iframe> 
    </body>
        <script type="text/javascript">
        var dropzone = document.getElementById("dropzone");
        var embedded = document.getElementById("embedded");
        var allFiles = {};
        var prefix = "app";
        function toggleSameOrigin() {
	        var val = document.getElementById("same-origin-checkbox").checked;
	        if(val) {
		        embedded.setAttribute("sandbox", "allow-same-origin allow-scripts");
	        } else {
		        embedded.setAttribute("sandbox", "allow-scripts");
	        }
        }
        dropzone.addEventListener("dragover", function(event){
            event.preventDefault();
        }, false);
        dropzone.addEventListener("drop", function(event){
            event.preventDefault();
            let items = event.dataTransfer.items;
            allFiles = {};
            for(let i =0; i < items.length; i++){
                loadFiles(items[i].webkitGetAsEntry(), allFiles);
            }
        }, false);
        
        var errorCallback = function(e){
            console.log(e);
        }
        var dirCount = 0;
        function loadFiles(item, allFiles) {
                if(!item.isDirectory){
                    item.file(function(file){                    	
                       var filereader = new FileReader();
            			filereader.onload = function(){
            				let fullPath = prefix + item.fullPath;
            				allFiles[fullPath] = new Uint8Array(this.result);
        					console.log("added:" + fullPath);
            			};
			            filereader.readAsArrayBuffer(file);

                    }, errorCallback);
                }
        }
        
        function reload() {
        		console.log("reloading!");
                function StreamWrapper() {
                    this.writer = null;
                    this.readFile = function(filePath) {
            				var fileData = allFiles[filePath];
            				let encoder = new TextEncoder();
                           let uint8Array = encoder.encode(filePath);
                           var filePathByte = new Uint8Array(1);
                           filePathByte[0] = uint8Array.byteLength;//todo len > 255
                           const headerSize = filePathByte.byteLength + uint8Array.byteLength;
                           var data = new Uint8Array(headerSize + fileData.byteLength);
                           data.set(filePathByte);
                           data.set(uint8Array, filePathByte.byteLength);
                           data.set(fileData, headerSize);
                            this.writer.write(data);
                    }
                }
                const wrapper = new StreamWrapper();
                var that = this;
                let fileStream = streamSaver.createWriteStream("web-viewer-", "text/html", function(url){
                    	that.embedded.src = prefix + "/page.html";
                    }, function(seekHi, seekLo, seekLength){
                        //nothing
                    }, undefined, 0
                    ,function(filePath){
                        wrapper.readFile(filePath)
                    }
                )
                wrapper.writer = fileStream.getWriter()
        }
        let encoder = new TextEncoder();
        let defaultIndexPageData = encoder.encode('<html lang="en"><body><h1>use dnd to set page.html + resource files</h1></body></html>');
        allFiles["app/page.html"] = new Uint8Array(defaultIndexPageData);
        </script>
</html>
